<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>
	</title>
</head>
<body>
<script>

//@@@@@@@@@@@@@@@@@@@ Array: Prints each index value, and type@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// 	var x = [3,5,'Dojo', 'rocks', {name: 'Michael', title: 'Sensei'}];
// 	var result=0;
// 	for (i=0; i<x.length; i++) 
// 	{
// 	 	console.log(x[i]);
// 		console.log (typeof(x[i]));
//     }
//       x.push(100);
	   
// 	   console.log(x);
// 	   for(i=0; i<=500; i++)
// 	{
// 		result = result+i;
// }

//@@@@@@@@@@@@@@@@@@@ Printing # in incrementation @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		
		// var symbol = "#";
		// console.log("#");
	 // 	 for(i=1; i<7; i++)
		// {
		// 		symbol = symbol + "#";
		// 		console.log(symbol);	
		// }

//@@@@@@@@@@@@@@@@@@@ 8x8 board : Good example of nested for loop@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

 //    var size = 8;
	// var board = "";

	// for (var y = 0; y < size; y++) {
	//   for (var x = 0; x < size; x++) {
	//     if ((x + y) % 2 == 0)
	//       board += " ";
	//     else
	//       board += "#";
	//   }
	//   board += "\n";
	// }

	// console.log(board);

//@@@@@@@@@@@@@@@@@@ Local and Global variables @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// var x = "outside";

// var y = function() {

// 	var x = "inside y";
// }

// y();
// console.log(x);
// // → outside

// var f2 = function() {
//   x = "inside f2";
// };
// f2();
// console.log(x);
// // → inside f2

// //@@@@@@@@@@@@@@@@@@ Closure Example: Create a mountain w/ dashes @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// var landscape = function() {
// 		var result = "";
// 		var flat = function(size) {
// 			for(var count=0; count < size; count++)
// 				result += "-_-";
// 		};

//         var mountain = function(size) {
//         	result += "/";
// 			for( var count=0; count < size; count++)
// 				result += "'";
// 				result += "\\";
// 		};
        
//         flat(1);
//         mountain(1);
// 		flat(1);
// 		mountain(1);
// 		flat(6);
// 		mountain(1);
// 		flat(1);
// 		mountain(1);
// 		flat(1);
// 		return result;
// };

// console.log(landscape());

// var landscape = function() {
//   var result = "";
//   var flat = function(size) {
//     for (var count = 0; count < size; count++)
//       result += "_";
//   };
//   var mountain = function(size) {
//     result += "/";
//     for (var count = 0; count < size; count++)
//       result += "'";
//     result += "\\";
//   };

//   flat(3);
//   mountain(4);
//   flat(6);
//   mountain(1);
//   flat(1);
//   return result;
// };

// console.log(landscape());

//@@@@@@@@@@@@@@@@@@@@@ Objects and Arrays @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/*This feature—being able to reference a specific instance of local variables in an enclosing function—is called closure. 
A function that “closes over” some local variables is called a closure. This behavior not only frees you from having to worry 
about lifetimes of variables but also allows for some creative use of function values.*/

// function min(num1, num2) {
// 		if (num1 < num2) {
// 			return num1;
// }
// 		else {
// 			return num2;
// }
 
// };

// console.log (min(2,3));
// console.log(min(-4,100));

/*Write a range function that takes two arguments, start and end, and returns an array containing all the numbers from start up 
to (and including) end.
*/

// function range(start,end) {
// 	var result=[];
//           while(start<=end)
//           {
// 		   result.push(start)
// 		     start+=1;
//            }

//     return result;
// };
// console.log(range(23,45));

/*As a bonus assignment, modify your range function to take an optional third argument that indicates the “step” value used to build up the array.
 If no step is given, the array elements go up by increments of one, corresponding to the old behavior. The function call range(1, 10, 2) 
 should return [1, 3, 5, 7, 9]. Make sure it also works with negative step values so that range(5, 2, -1) produces [5, 4, 3, 2].*/
 //Next, write a sum function that takes an array of numbers and returns the sum of these numbers. Run the 
//previous program and see whether it does indeed return 55.

// function range(start, end, step) {
//   if (step == null) step = 1;
//   var array = [];

//   if (step > 0) {
//     for (var i = start; i <= end; i += step)
//       array.push(i);
//   } else {
//     for (var i = start; i >= end; i += step)
//       array.push(i);
//   }
//   return array;
// }
// range(2,7,1);

// function sum(array) {
//   var total = 0;
//   for (var i = 0; i < array.length; i++)
//     total += array[i];
//   return total;
// }

// console.log(sum(range(1, 10)));
// // → 55
// console.log(range(5, 2, -1));
// // → [5, 4, 3, 2]

// For this exercise, write two functions,reverseArray and reverseArrayInPlace. The first, reverseArray, takes an array as argument and produces a new array that has the same elements in the inverse order. 

//using a temp variable

// function reverse(a) {
//     var temp = [];
//     //var len = a.length;
//     for (var i = a.length-1; i >= 0; i--) {
//         temp.push(a[i]);
//         //a[i] = temp[i];
//     }
//     a = temp;
//     return a;
// }
// arrayvalue = [1,2,3,4];
// console.log(reverse(arrayvalue))

// var totalGen = 19;   
// var totalMW = 0;
// //2,4,6,8,10,12,14,16,18 produce power
// //1-4-->produce 62MW
// //5-19-->produce 124MW
// for(var generator=0; generator<=totalGen; generator++)
// {
//   if (generator%2 == 0) {
//     if(generator ==2 || generator==4) {
//       totalMW+= 62;
//       console.log("Generator " + generator + " is on, adding 62MW, for a total of" + totalMW );
//     } else {
//        totalMW+= 124;
//       console.log("Generator " + generator + " is on, adding 62MW, for a total of" + totalMW );
//     }
//   } else {
//     console.log ("Generator " generator + " is off");
  
//   }
// }
// function countB(string) {
// var count =0;
// 	for (var i=0 ; i <string.length; i++)
// 	{
// 		if (string.charAt(i) == “B”)
// 		{
// 			count+= 1;
// 		}
// 	}
// 	return count;

// }
// console.log(countB("BBC"));

// function LetterCapitalize(str) {
//     var c=[];
//     var sep= str.split(" ");
//     for(var i=0; i<sep.length; i++) {
//     		c.push(sep[i][0].toUpperCase() + sep[i].slice(1));

//     }
//     return c.join(" ");
// }
// console.log(LetterCapitalize("BBC is me"));

///@@@@@@@@@@@@@@@@ In builf Methods: map, shift @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// var passengers = [ ["Thomas", "Meeks"],
//                    ["Gregg", "Pollack"],
//                    ["Christine", "Wong"],
//                    ["Dan", "McGaw"] ];

// var modifiedNames = passengers.map(function(arrayCell) {
// 	return arrayCell[0] + " " + arrayCell[1];
// }
// );
// console.log(modifiedNames);

// var puzzlers = [
//   function(a) { return 8 * a - 10; },
//   function(a) { return (a - 3) * (a - 3) * (a - 3); },
//   function(a) { return a * a + 4; },
//   function(a) { return a % 5; }
// ];
// var start = 2;

// // build applyAndEmpty function expression here
// var applyAndEmpty = function(input, queue) {
// 		for(var i=0; i < queue.length +i; i++)
//     { input = queue.shift()(input); }
// return input
// };
// console.log (applyAndEmpty(start, puzzlers));

//@@@@@@@@@@@@@@@@@@@@@@@ GREAT CLOSURE EXAMPLES @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// var hidden = mystery(3);
// var jumble = mystery3(hidden);
// var result = jumble(2);

// function mystery ( input ){
//   var secret = 4;
//   input+=2;
//   function mystery2 ( multiplier ) { 
//     multiplier *= input;
//     return secret * multiplier;
//   }
//   return mystery2;
// }
// function mystery3 ( param ){
//   function mystery4 ( bonus ){
//     return param(6) + bonus;
//   }
//   return mystery4;
// }
 
//  function warningMaker(obstacle) {
//   var count = 0;
//   var zones = [];
//   return function(number, location) {
//   	var list = "";
//   	    count++;
//    zones.push([location, number]);
//     for (var i = 0; i < zones.length; i++) {
//   list += zones[i][0] + " (" + zones[i][1] + ")" + "\n";
// }
//     alert("Beware! There have been " + obstacle +
//           " sightings in the Cove today!\n" +
//           number + " have been spotted at the " +
//           location + "!\n" + "This is alert #" +
//           count + " today for " + obstacle + " danger." +
//           "Current danger zones are:\n" +
//           list
          
//     );
//   };
// }

// var warning = warningMaker("blizzard");
// warning(4, "Market Street");
// warning(9, "Philly Street");


//@@@@@@@@@@@@@@@@@@@@@@@@@@ OBJECTS @@@@@@@@@@@@@@@@@@@@@@@@@

// var vehicle1 = {type: "Motorboat", capacity: 6, storedAt: "Ammunition Depot"};
// var vehicle2 = {type: "Jet Ski", capacity: 1, storedAt: "Reef Dock"};
// var vehicle3 = {type: "Submarine", capacity: 8, storedAt: "Underwater Outpost"};

// // create vehicles array
// var vehicles = [];
// vehicles.push(vehicle1);
// vehicles.push(vehicle2);
// vehicles.push(vehicle3);
// // build findVehicle function expression
// var findVehicle = function(name, list) {
//   for(var i=0; i<=list.length; i++) {
//     if (list[i].type == name) {
//   			return list[i].storedAt;
//   }
  
//   }
// };

// // call findVehicle
// console.log(findVehicle("Submarine", vehicles));


// var bob = {
//     firstName: "Bob",
//     lastName: "Jones",
//     phoneNumber: "(650) 777-7777",
//     email: "bob.jones@example.com"
// };

// var mary = {
//     firstName: "Mary",
//     lastName: "Johnson",
//     phoneNumber: "(650) 888-8888",
//     email: "mary.johnson@example.com"
// };

// var contacts = [bob, mary];

// var printPerson = function(person) {
//     console.log(person.firstName + " " + person.lastName);
   
// };

// printPerson(contacts[0]);
// printPerson(contacts[1]);

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ SCOPING @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// var myFunction = function () {
//   var name = 'Todd';
//   var myOtherFunction = function () {
//   	name = "Boshika"
//   	console.log('My name is ' + name);
//   };
//   console.log(name);

// myOtherFunction();
 
// };

// console.log(myFunction());
// console.log(myFunction());

/*OUTPUT
								 Todd
javascript fundamnetals.html:390 My name is Boshika
javascript fundamnetals.html:398 undefined
javascript fundamnetals.html:392 Todd
javascript fundamnetals.html:390 My name is Boshika */

//Lexical scope is easy to work with, any variables/objects/functions defined in it's parent scope, are available in the scope chain. For example:

// var name = 'Todd';
// var scope1 = function () {
//   // name is available here
//   var scope2 = function () {
//     // name is available here too
//     var scope3 = function () {
//       // name is also available here!
//     };
//   };
// };

//The only important thing to remember is that Lexical scope does not work backwards. Here we can see how Lexical scope doesn't work:

// // name = undefined
// var scope1 = function () {
//   // name = undefined
//   var scope2 = function () {
//     // name = undefined
//     var scope3 = function () {
//       var name = 'Todd'; // locally scoped
//     };
//   };
// };

// var sayHello = function (name) {
//   var text = 'Hello, ' + name;
//   return function () {
//     console.log(text);
//   };
// };

// sayHello("Todd")();

//  function myString(str) {

// 	var myArray = str.split(" ");
// 	var count= 0;
// 	for(var i=0; i<myArray.length; i++)
// 	{
// 		count+=1;
// 	}
// 	return count;
// }

// console.log (myString("Hell0 World"));


// var message = 'yes';

// for(var i = 0; i < 5; i++){
//   var message = 'no';
// };

// console.log('Is there block scope? ' + message);

/*output Is there block scope? no */

//@@@@@@@@@@@@ Closure @@@@@@@@@@@@@@@@@@

// var closureAlert = function(){
//   var x = 'Help! I\'m a variable '+
//     'stuck in a closure!';
  
//   var alerter = function(){
//     alert(x);
//   };
  
//   alerter();
// };

// closureAlert();

// var closureAlert = function(){ 
//   var x = 0; 
//   var alerter = function(){ 
//     x++;
//     alert(x); 
//   }; 
//   return alerter; 
// }; 

// var alerter1 = closureAlert(); 
// var alerter2 = closureAlert(); 
// alerter1();
// alerter2();

/*Output Both will return 1. Here is why: alerter 1 and 2 are seperate instances of each other. This is the magic of closure, each one has its own closure scope, hence seperate reference of var x. */

// var add = function(num){
//   var num1 = num;

//   var addToNum1 = function(num2){
//     return num1 + num2;
//   };

//   return addToNum1;
// };
// var addEleven = add(11);
// var result = addEleven(22);
// console.log(result);

/* OUTPUT 33 * demonstrates key concept: closure reference means the value persists because of addEleven variable*/

function counter() {
  var n = 0;

  return {
    count: function() { n++; return n; },
    reset: function() { n = 0; }
  };
}

var c = counter();
var d = counter();

c.count();
d.count();

c.reset();
c.count();
d.count();

/* OUTPUT  c will be 1, and d will be 2.*/

// @@@@@@@@@@@@@@@@@@@@@@@@ RECIPE FOR CLOSURES @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

/* RECIPE FOR CLOSURE 
1. Create your parent function.
2. Define some variables in the parent's local scope.
     (they can be accessed by the child function)
3. Define a function inside the parent function.
     (aka defining a "child" function or "nested" function)
4. Return that child from inside the parent.
function outerFunc() {
  var parentVar = "local to parent";
  function innerFunc() {
    return parentVar + ' but accessed by child!';
  };
  return innerFunc;
} 
function outerFunc() {
  var parentVar = "local to parent";
  function innerFunc() {
    return parentVar + ' but accessed by child!';
  };
  return innerFunc;
}



// STEP 1 - Run the parent function.
var example = outerFunc();
console.log(example);
// We see example now stores the child.

// STEP 2 - Run the child function.
var result = example();
console.log(result);
// What's the end result?

*/

// var sayAlice = function(){

//   var makeLog = function() {
//     console.log(alice);
//   };

//   var alice = 'Why hello there, Alice!';

//   return makeLog;
// };

// var log = sayAlice();

// log();

// var makeStopwatch = function(){
//   var elapsed = 0;

//   var stopwatch = function(){
//     return elapsed;
//   };

//   var increase = function(){ elapsed++; };
//   setInterval(increase, 1000);

//   return stopwatch;

// };

// var x = makeStopwatch();

//@@@@@@@@@@@@@@@@@@@@@ MODULE PATTERN - BOILERPLATE @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// var Module = function(){

//   var privateProperty = 'I like big fonts,' +
//     ' and I cannot lie';

//   function privateMethod(params){
//     // do something
//   };

//   return {
//     publicProperty: 'JS rulez!!',
//     publicMethod: function(params){
//       // do something
//     },
//     privilegedMethod: function(params){ 
//       privateMethod(args); 
//     }
//   };
// };

// var makeNewCar = function(){
//   var brakeLightsOn = false, seatbeltLocked = false;

//   function useABS(pressure) {
//     // 1. Use Electronic Brakeforce Distribution.
//     // 2. If necessary, activate Stability Control.
//     // 3. Check if wheels are locking up.
//     // 4. If necessary, release and re-apply EBD.
//   }

//   return {
//     color: 'blue',
//     honkHorn: function() {
//       console.log('HONK!!!');
//     },
//     hitBrakes: function(pressure){
//       brakeLightsOn = true;
//       seatbeltLocked = true;
//       useABS(pressure);
//     }
//   };

// };

//@@@@@@@@@@@@@@@@@@@@@@@ HIGH ORDER FUNCTIONS @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

// var ifElse = function(condition, isTrue, isFalse){
//   if(condition){
//     isTrue();
//   } else {
//     isFalse();
//   }
// };

// var logTrue = function(){ console.log(true); };
// var logFalse = function(){ console.log(false); };

// ifElse(true, logTrue, logFalse);


// var increment = function(n){
//   return n + 1;
// };

// var square = function(n){
//   return n*n;
// };

// var doMathSoIDontHaveTo = function(n, func){
//   return func(n);
// };

// doMathSoIDontHaveTo(5, square);

// doMathSoIDontHaveTo(4, increment);

//@@@@@@@@@@@@@@ reduce and concat method as callbacks @@@@@@@@@@@@@@@@@@@@

// var arrays = [[1,2,3],[4,5]];
// var conacatthis = function(thisArray) {
// 	return thisArray.reduce(function (start,next) {return start.concat(next)});
// };

// console.log(conacatthis(arrays));



</script>
</body>
</html>
